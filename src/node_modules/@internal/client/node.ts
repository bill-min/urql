import fetchImpl, { FetchOptions } from "make-fetch-happen";
import https from "https";
import {
  createClient,
  dedupExchange,
  cacheExchange,
  fetchExchange,
  ssrExchange,
  type ClientOptions,
  type Client,
} from "@urql/core";
import { DEFAULT_CLIENT_NAME } from "../shared";

type FetchFn = (
  uriOrRequest: string | Request,
  opts?: FetchOptions,
) => ReturnType<typeof fetchImpl>;

const kClientMap = Symbol("client_map");
const { ca } = https.globalAgent.options;
const strictSSL = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";

function internalFetch(url: string | Request, options?: FetchOptions) {
  return fetchImpl(url, { ...options, ca, strictSSL });
}

export const readyLookup = {};

export function getClient(out: any, name = DEFAULT_CLIENT_NAME): Client {
  const client = out.global[kClientMap]?.get(name);
  if (!client) throw new Error("<gql-client> not configured.");
  return client;
}

export function configureClient(
  config: ClientOptions & {
    fetch?: (
      ...params: [...Parameters<FetchFn>, FetchFn]
    ) => ReturnType<FetchFn>;
  },
  out: any,
  name = DEFAULT_CLIENT_NAME,
) {
  let exchanges = [
    dedupExchange,
    cacheExchange,
    ssrExchange({ isClient: false }),
    fetchExchange,
  ];

  if (config.exchanges) {
    exchanges = config.exchanges.concat(exchanges);
  }

  const client = createClient({
    ...config,
    exchanges,
    fetch: async (url, options: any) => {
      const fetchImplOverride = config.fetch
        ? (...params: Parameters<FetchFn>) =>
            config.fetch!(...params, internalFetch)
        : internalFetch;
      const incomingMessage =
        (out.stream && (out.stream.req || out.stream.request)) ||
        out.global.req ||
        out.global.request;
      if (typeof url !== "string") throw new Error("Expected a string.");
      if (!incomingMessage) return fetchImplOverride(url, options) as any;
      const protocol =
        incomingMessage.headers["x-forwarded-proto"] ||
        incomingMessage.protocol;
      const host =
        incomingMessage.headers["x-forwarded-host"] ||
        incomingMessage.headers.host;
      return fetchImplOverride(
        new URL(url, `${protocol}://${host}`).toString(),
        {
          ...options,
          headers: {
            ...incomingMessage.headers,
            ...options?.headers,
          },
        },
      ) as any;
    },
  });

  if (out.global[kClientMap]) {
    out.global[kClientMap].set(name, client);
  } else {
    out.global[kClientMap] = new Map([[name, client]]);
  }
}

export function hydrateQuery() {
  throw new Error("Cannot be called on the server.");
}
