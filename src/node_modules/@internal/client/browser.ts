import {
  createClient,
  dedupExchange,
  cacheExchange,
  fetchExchange,
  ssrExchange,
  type ClientOptions,
  type Client,
  type Exchange,
} from "@urql/core";

import { devtoolsExchange } from "@internal/client/devtools";

const DEFAULT_CLIENT_NAME = "default";

interface ClientProvider {
  client?: Client;
  ssr?: ReturnType<typeof ssrExchange>;
}

const clientProviderMap = new Map<string, ClientProvider>();

export const readyLookup = {};

export function getClient(_out: any, name = DEFAULT_CLIENT_NAME) {
  assertConfigured(name);
  return clientProviderMap.get(name)!.client!;
}

export function configureClient(
  config: ClientOptions & {
    fetch?: (
      ...params: [...Parameters<typeof fetch>, typeof fetch]
    ) => ReturnType<typeof fetch>;
    name?: string;
    cacheExchange?: Exchange;
  },
  _out: any,
) {
  const clientProvider: ClientProvider = {};
  clientProvider.ssr = ssrExchange({ isClient: true });
  let exchanges = [
    config.cacheExchange ?? cacheExchange,
    dedupExchange,
    clientProvider.ssr,
    fetchExchange,
  ];
  if (process.env.NODE_ENV !== "production" && devtoolsExchange) {
    exchanges.push(devtoolsExchange);
  }

  if (config.exchanges) {
    exchanges = config.exchanges.concat(exchanges);
  }

  clientProvider.client = createClient({
    ...config,
    exchanges,
    fetch: config.fetch
      ? (...params: Parameters<typeof fetch>) => config.fetch!(...params, fetch)
      : fetch,
  });

  clientProviderMap.set(config.name || DEFAULT_CLIENT_NAME, clientProvider);
}

export function hydrateQuery(
  opKey: string,
  data: any,
  error: any,
  name = DEFAULT_CLIENT_NAME,
) {
  assertConfigured(name);
  clientProviderMap.get(name)!.ssr!.restoreData({
    [opKey]: {
      data: data ? JSON.stringify(data) : undefined,
      error,
    },
  });
}

function assertConfigured(name: string) {
  const clientProvider = clientProviderMap.get(name);
  if (!clientProvider?.client || !clientProvider.ssr)
    throw new Error("<gql-client> not configured.");
}
